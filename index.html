<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>333 — Night Void (Visualizer Fixed)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
:root{ --white:#ffffff; --muted: rgba(255,255,255,0.08); }
*{box-sizing:border-box;margin:0;padding:0;font-family:'Inter',sans-serif}
html,body{height:100%;background:#000;color:var(--white);overflow:hidden}
body{display:flex;align-items:center;justify-content:center;cursor:none}

/* BACKGROUND + LAYERS */
.bg{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:0;filter:brightness(0.28) contrast(1.2);transition:transform .25s ease-out;}
canvas#snow,canvas#fog,canvas#grain,canvas#particles{position:fixed;inset:0;width:100%;height:100%;z-index:1;pointer-events:none;}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);backdrop-filter:blur(2px);z-index:2;pointer-events:none}
.scanlines{position:fixed;inset:0;z-index:4;pointer-events:none;background:repeating-linear-gradient(to bottom,rgba(255,255,255,0.02)0px,rgba(255,255,255,0.02)1px,transparent 2px,transparent 3px);mix-blend-mode:overlay;opacity:0.25}

/* ENTER SCREEN */
#enterScreen{position:fixed;inset:0;z-index:60;display:flex;align-items:center;justify-content:center;flex-direction:column;background:#000}
#enterText{font-size:1.6rem;letter-spacing:6px;text-transform:uppercase;color:transparent;-webkit-text-stroke:0.9px rgba(255,255,255,0.95);cursor:none;padding:14px 30px;border-radius:999px;transition:transform .18s ease,opacity .5s ease;user-select:none}
#enterText:hover{transform:scale(1.03)}
#enterScreen.fade{opacity:0;pointer-events:none;transition:opacity .9s ease}

/* CENTER content */
#center{position:relative;z-index:10;display:flex;align-items:center;flex-direction:column;gap:10px;pointer-events:auto;transform:translateY(20px);opacity:0;transition:transform 900ms cubic-bezier(.2,.9,.2,1),opacity 900ms ease}
#center.show{transform:none;opacity:1}

/* PFP/AURA */
.pfp{width:120px;height:120px;border-radius:999px;overflow:visible;position:relative;z-index:11}
.pfp img{width:120px;height:120px;border-radius:999px;object-fit:cover;display:block;filter:grayscale(1) contrast(1.02)}
.aura{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none;width:360px;height:360px;border-radius:50%;z-index:9;mix-blend-mode:screen;filter:blur(28px);opacity:0.9;background:radial-gradient(circle at 40% 30%,rgba(255,255,255,0.16),rgba(255,255,255,0.06)18%,rgba(255,255,255,0.00)50%)}

/* TITLE */
h1{font-size:2.2rem;letter-spacing:6px;margin-top:6px;background:linear-gradient(90deg,#fff,#bdbdbd,#fff);background-size:220% auto;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation:shimmer 3.5s linear infinite;z-index:11}
@keyframes shimmer{0%{background-position:0% 50%}100%{background-position:200% 50%}}

/* ICONS */
.icon-row{display:flex;gap:18px;margin-top:14px;z-index:11}
.icon{width:44px;height:44px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);transition:transform .25s,box-shadow .25s;cursor:none}
.icon img{width:22px;height:22px;filter:grayscale(1);opacity:0.95}
.icon:hover{transform:translateY(-6px) scale(1.08);box-shadow:0 12px 40px rgba(255,255,255,0.04)}

/* VISUALIZER (container) */
#visualizer{display:flex;gap:4px;margin-top:20px;align-items:flex-end;height:64px;z-index:11;transition:height .2s}
.vbar{width:8px;background:linear-gradient(to top,#fff,#bdbdbd);border-radius:3px;opacity:0.85;transform-origin:bottom center;transition:height .06s linear,opacity .06s linear}

/* CONTROLS */
#controls{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;z-index:40;display:flex;align-items:center;gap:10px;padding:8px 12px;border-radius:999px;background:rgba(0,0,0,0.25);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.04)}
.btn{width:36px;height:36px;display:grid;place-items:center;border-radius:8px;background:rgba(255,255,255,0.03);cursor:none;transition:transform .12s,background .12s}
.btn:hover{transform:scale(1.06);background:rgba(255,255,255,0.08)}
.icon-white{width:18px;height:18px;filter:invert(1) grayscale(1) brightness(1.2)}

/* VOLUME & SOURCE SELECT */
.sourceRow{display:flex;gap:8px;align-items:center}
select,input[type="text"]{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;color:#fff;outline:none}
input[type="file"]{color:#fff}

/* CURSOR & TRAIL */
.cursor{position:fixed;width:14px;height:14px;border-radius:50%;background:rgba(255,255,255,0.95);box-shadow:0 0 18px rgba(255,255,255,0.75),0 0 40px rgba(255,255,255,0.06);pointer-events:none;z-index:9999;transform:translate(-50%,-50%);transition:transform .15s ease, width .15s ease, height .15s ease, opacity .15s ease;mix-blend-mode:screen}
.cursor.hover{width:22px;height:22px;opacity:0.9}
.trail{position:fixed;width:6px;height:6px;border-radius:50%;background:rgba(255,255,255,0.72);pointer-events:none;z-index:9998;transform:translate(-50%,-50%);filter:blur(1.4px);opacity:0.8;animation:trailFade 500ms linear forwards}
@keyframes trailFade{0%{opacity:0.9;transform:translate(-50%,-50%) scale(1)}100%{opacity:0;transform:translate(-50%,-50%) scale(1.8)}}

/* FLICKER SWEEP */
.flicker{position:fixed;left:-10%;top:0;width:30%;height:100%;transform:skewX(-12deg);background:linear-gradient(90deg,rgba(255,255,255,0),rgba(255,255,255,0.04),rgba(255,255,255,0));mix-blend-mode:screen;z-index:8;pointer-events:none;opacity:0;transition:opacity .12s ease}

/* accessible focus outline for keyboard users */
button:focus, a:focus, input:focus, select:focus, #enterText:focus{outline:2px solid rgba(255,255,255,0.12); outline-offset:4px}

/* responsive */
@media(max-width:520px){ .pfp{width:96px;height:96px}.pfp img{width:96px;height:96px} h1{font-size:1.6rem} #visualizer{height:46px} #controls{bottom:14px} }
</style>
</head>
<body>
<!-- ENTER -->
<div id="enterScreen"><div id="enterText" tabindex="0">Enter the Void</div></div>

<!-- BACKGROUND + CANVASES -->
<img class="bg" src="https://media.tenor.com/Ua5qB1eng_oAAAAC/black-and-white-night-city.gif" alt="night city">
<canvas id="particles"></canvas>
<canvas id="snow"></canvas>
<canvas id="fog"></canvas>
<canvas id="grain"></canvas>
<div class="overlay"></div>
<div class="scanlines"></div>
<div class="flicker" id="flick"></div>

<!-- CENTER (no ribbon) -->
<div id="center" aria-hidden="true">
  <div class="aura" id="aura"></div>
  <div class="pfp" id="pfp">
    <img src="https://i.imgur.com/OJeD12w.jpeg" alt="pfp">
  </div>
  <h1 id="title">333</h1>

  <div class="icon-row" id="icons">
    <a class="icon" href="https://discord.com" target="_blank" rel="noreferrer"><img src="https://cdn-icons-png.flaticon.com/512/2111/2111370.png" alt="discord"></a>
    <a class="icon" href="https://t.me" target="_blank" rel="noreferrer"><img src="https://cdn-icons-png.flaticon.com/512/2111/2111646.png" alt="telegram"></a>
  </div>

  <div id="visualizer" aria-hidden="true">
    <!-- 32 bars for better resolution -->
    <!-- These bars are controlled by the visualizer script below -->
  </div>
</div>

<!-- CONTROLS (visible after Enter) -->
<div id="controls" style="display:none" aria-hidden="true">
  <button class="btn" id="playBtn" title="Play/Pause" aria-pressed="false" aria-label="Play/Pause">
    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="#fff" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><path d="M5 3v18l15-9L5 3z"/></svg>
  </button>
  <button class="btn" id="muteBtn" title="Mute/Unmute" aria-pressed="false" aria-label="Mute/Unmute">
    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#fff" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H3v6h3l5 4V5z"/><path d="M19 9a4 4 0 010 6"/></svg>
  </button>

  <!-- Source switch: audio file (real analyzer) or YouTube (fallback) -->
  <div class="sourceRow" aria-hidden="false" style="gap:6px">
    <label for="sourceSelect" style="font-size:12px;opacity:0.85">Source</label>
    <select id="sourceSelect" title="Choose audio source">
      <option value="audio">Audio file (real analyzer)</option>
      <option value="youtube">YouTube (fallback visualizer)</option>
    </select>

    <!-- text input to paste a CORS-enabled MP3 URL (or sample is loaded by default) -->
    <input id="audioUrl" type="text" placeholder="Paste MP3 URL (optional)" style="min-width:260px" aria-label="Audio URL">
    <input id="fileInput" type="file" accept="audio/*" aria-label="Choose local audio file">
  </div>

  <input id="vol" type="range" min="0" max="100" value="70" aria-label="Volume">
</div>

<!-- Hidden media elements -->
<!-- audio element used for WebAudio analysis. Default sample file (works out-of-the-box). -->
<audio id="audioEl" crossorigin="anonymous" style="display:none" preload="auto">
  <!-- Default sample: MDN t-rex roar — public test file that supports CORS for examples (works immediately).
       Replace this src with your own CORS-enabled mp3 or load local file via the file input.
  -->
  <source id="audioSrc" src="https://interactive-examples.mdn.mozilla.net/media/examples/t-rex-roar.mp3" type="audio/mpeg">
</audio>

<!-- Hidden YouTube player host (keeps your previous YT player behavior) -->
<div id="ytHost" style="width:1px;height:1px;overflow:hidden;position:fixed;left:-9999px;top:-9999px;"></div>

<div class="cursor" id="cursorEl"></div>

<script>
/* ======= DOM References ======= */
const enterScreen = document.getElementById('enterScreen');
const enterText = document.getElementById('enterText');
const center = document.getElementById('center');
const cursorEl = document.getElementById('cursorEl');
const controls = document.getElementById('controls');
const playBtn = document.getElementById('playBtn');
const muteBtn = document.getElementById('muteBtn');
const volRange = document.getElementById('vol');
const visualizerEl = document.getElementById('visualizer');
const flick = document.getElementById('flick');

const audioEl = document.getElementById('audioEl');
const audioUrl = document.getElementById('audioUrl');
const fileInput = document.getElementById('fileInput');
const sourceSelect = document.getElementById('sourceSelect');

let ytPlayer = null;
let isPlaying = false;
let isMuted = false;

/* ======= Build visualizer bars (32 bars) ======= */
const BAR_COUNT = 32;
for(let i=0;i<BAR_COUNT;i++){
  const div = document.createElement('div');
  div.className = 'vbar';
  div.style.height = '8px';
  visualizerEl.appendChild(div);
}
const vbars = Array.from(document.querySelectorAll('.vbar'));

/* ======= YouTube IFrame API (lazy load after user gesture) ======= */
function loadYouTubeAPI(cb){
  if(window.YT && window.YT.Player){ cb(); return; }
  const s = document.createElement('script');
  s.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(s);
  window.onYouTubeIframeAPIReady = cb;
}
function createYTPlayer(){
  const host = document.getElementById('ytHost');
  const div = document.createElement('div');
  div.id = 'ytPlayerEl';
  host.appendChild(div);
  ytPlayer = new YT.Player('ytPlayerEl', {
    height: '1', width: '1', videoId: 'OAyixxm4yXw',
    playerVars: { autoplay: 1, controls: 0, loop: 1, playlist: 'OAyixxm4yXw', rel: 0, modestbranding: 1 },
    events: {
      onReady: (e) => {
        const v = parseInt(volRange.value, 10);
        try{ ytPlayer.setVolume(v); ytPlayer.playVideo(); }catch(e){}
        isPlaying = true; updatePlayIcon(); showControls();
      },
      onStateChange: (ev) => { if(ev.data === YT.PlayerState.ENDED){ ytPlayer.playVideo(); } }
    }
  });
}

/* ======= Enter workflow ======= */
enterText.addEventListener('click', startExperience);
enterText.addEventListener('keydown', (e)=> { if(e.key === 'Enter' || e.key === ' ') startExperience(); });

function startExperience(){
  enterScreen.classList.add('fade');
  setTimeout(()=> enterScreen.style.display='none',900);
  center.classList.add('show');
  center.removeAttribute('aria-hidden');
  flick.style.opacity = 0.22; setTimeout(()=> flick.style.opacity = 0, 240);

  // start canvases/particles (they run independently below)
  spawnSnow(); spawnFog(); drawGrain();

  // load YT API (keeps Youtube playback behavior)
  loadYouTubeAPI(()=> createYTPlayer());

  // show controls
  showControls();

  // by default we start the audio element (sample file) so analyzer has data immediately.
  // if user prefers YT they can switch select to "YouTube"
  audioEl.load();
  audioEl.play().catch(()=>{/* autoplay blocked until user gesture — user clicked Enter already */});
}

/* ======= Controls handling ======= */
function showControls(){
  controls.style.display = 'flex';
  controls.setAttribute('aria-hidden','false');
}
function updatePlayIcon(){
  playBtn.innerHTML = isPlaying ?
    '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="#fff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="5" width="4" height="14" rx="1"/><rect x="14" y="5" width="4" height="14" rx="1"/></svg>' :
    '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="#fff" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><path d="M5 3v18l15-9L5 3z"/></svg>';
  playBtn.setAttribute('aria-pressed', String(isPlaying));
}
playBtn.addEventListener('click', () => {
  // play/pause both audio element and youtube (depending on selected source)
  if(sourceSelect.value === 'audio'){
    if(audioEl.paused){ audioEl.play(); isPlaying=true; } else { audioEl.pause(); isPlaying=false; }
  } else {
    if(!ytPlayer) return; // not ready
    if(isPlaying){ ytPlayer.pauseVideo(); isPlaying=false; } else { ytPlayer.playVideo(); isPlaying=true; }
  }
  updatePlayIcon();
});
muteBtn.addEventListener('click', () => {
  if(sourceSelect.value === 'audio'){
    if(audioEl.muted){ audioEl.muted = false; isMuted=false; muteBtn.setAttribute('aria-pressed','false'); }
    else{ audioEl.muted = true; isMuted=true; muteBtn.setAttribute('aria-pressed','true'); }
  } else {
    if(!ytPlayer) return;
    if(isMuted){ ytPlayer.unMute(); isMuted=false; muteBtn.setAttribute('aria-pressed','false'); } else { ytPlayer.mute(); isMuted=true; muteBtn.setAttribute('aria-pressed','true'); }
  }
});
volRange.addEventListener('input', () => {
  const v = parseInt(volRange.value,10) || 0;
  if(sourceSelect.value === 'audio'){
    audioEl.volume = v/100;
  } else {
    if(ytPlayer) ytPlayer.setVolume(v);
  }
});

/* ======= Source switching / audio loading ======= */
sourceSelect.addEventListener('change', () => {
  if(sourceSelect.value === 'audio'){
    // ensure audio is playing/ready
    audioEl.play().catch(()=>{/* may need another user gesture */});
  } else {
    // switched to YouTube: if YT exists, start YT and pause audio to avoid double audio
    try{ audioEl.pause(); }catch(e){}
    if(ytPlayer) { ytPlayer.playVideo(); isPlaying=true; updatePlayIcon(); }
  }
});

// paste URL to use remote mp3 (must support CORS)
audioUrl.addEventListener('change', () => loadAudioUrl());
audioUrl.addEventListener('paste', () => setTimeout(()=> loadAudioUrl(),50));
function loadAudioUrl(){
  const url = (audioUrl.value||'').trim();
  if(!url) return;
  // set audio source to custom URL
  document.getElementById('audioSrc').src = url;
  audioEl.load();
  audioEl.play().catch(()=>{/* user gesture may be needed */});
}

// local file drop
fileInput.addEventListener('change', (ev) => {
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const blobUrl = URL.createObjectURL(f);
  document.getElementById('audioSrc').src = blobUrl;
  audioEl.load();
  audioEl.play().catch(()=>{});
});

/* ======= Visualizer (real when using audio file) ======= */
let audioCtx = null;
let analyser = null;
let sourceNode = null;
let dataArray = null;
let bufferLength = 0;
let rafId = null;

function ensureAudioContext(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function setupAnalyserForAudioElement(){
  if(!audioEl) return;
  ensureAudioContext();
  // clean up previous nodes if any
  if(sourceNode){ try{ sourceNode.disconnect(); }catch(e){} sourceNode = null; }
  if(analyser){ analyser.disconnect(); analyser = null; }

  sourceNode = audioCtx.createMediaElementSource(audioEl);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048; // higher for smoother freq data
  bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);

  sourceNode.connect(analyser);
  analyser.connect(audioCtx.destination);
}

/* Map analyser frequency bins to BAR_COUNT bars */
function drawRealFrequency(){
  if(sourceSelect.value !== 'audio'){ // only draw when audio source selected
    cancelAnimationFrame(rafId);
    return;
  }
  if(!analyser){ setupAnalyserForAudioElement(); }
  if(!analyser) return;

  analyser.getByteFrequencyData(dataArray);

  // We'll sample the spectrum linearly across low->high frequencies
  const step = Math.floor(bufferLength / BAR_COUNT);
  for(let i=0;i<BAR_COUNT;i++){
    const binStart = i * step;
    // average across the step to smooth
    let sum = 0;
    for(let j=0;j<step;j++){
      sum += dataArray[binStart + j] || 0;
    }
    const avg = sum / step;
    // map avg [0..255] to height px (visualizerEl height)
    const maxH = visualizerEl.clientHeight || 64;
    const h = Math.max(4, Math.round((avg / 255) * maxH));
    vbars[i].style.height = h + 'px';
    vbars[i].style.opacity = 0.35 + (avg/255)*0.75;
  }
  rafId = requestAnimationFrame(drawRealFrequency);
}

/* Fake visualizer (used for YouTube fallback) — keeps good motion but isn't real audio */
function fakeEnergy(t){
  const beat = 0.9 + 0.4 * Math.abs(Math.sin(t*0.004 + 0.02));
  const rhythm = 0.5 + 0.45 * Math.abs(Math.sin(t*0.011 + 0.7));
  const bursts = (Math.sin(t*0.02) > 0.82) ? (0.2 + Math.random()*0.9) : (0.02*Math.random());
  return Math.min(1, (0.55*beat + 0.35*rhythm + 0.9*bursts) * (0.95 + 0.25*Math.random()));
}
let vizStart = 0;
function drawFakeViz(t){
  if(sourceSelect.value !== 'youtube'){ cancelAnimationFrame(rafId); return; }
  if(!vizStart) vizStart = t;
  const elapsed = t - vizStart;
  const E = fakeEnergy(elapsed);
  for(let i=0;i<BAR_COUNT;i++){
    const idx = i/BAR_COUNT;
    const local = E * (0.6 + 0.6*(1-idx)) + 0.12*Math.sin(elapsed*0.007*(1+idx*2)+i);
    const transient = (Math.random() < 0.02) ? (0.2 + Math.random()*0.8) : 0;
    const val = Math.min(1, Math.max(0, local + transient));
    const px = Math.max(6, Math.round(val * ((visualizerEl.clientHeight||64) - idx*8)));
    vbars[i].style.height = px + 'px';
    vbars[i].style.opacity = 0.35 + (val*0.65);
  }
  rafId = requestAnimationFrame(drawFakeViz);
}

/* Kick off the correct visualizer depending on the selected source */
function startVisualizerLoop(){
  cancelAnimationFrame(rafId);
  if(sourceSelect.value === 'audio'){
    // If audio context wasn't created (user may have to interact to resume AudioContext), create it
    try{ setupAnalyserForAudioElement(); }catch(e){ console.warn('analyser setup failed', e); }
    // if AudioContext is suspended, try to resume on user gesture
    if(audioCtx && audioCtx.state === 'suspended'){
      audioCtx.resume().catch(()=>{});
    }
    drawRealFrequency();
  } else {
    vizStart = 0;
    drawFakeViz(performance.now());
  }
}

/* When user interacts (plays, switches source, loads file) restart visualizer appropriately */
audioEl.addEventListener('play', ()=> { isPlaying = true; updatePlayIcon(); if(sourceSelect.value === 'audio'){ startVisualizerLoop(); }});
audioEl.addEventListener('pause', ()=> { isPlaying = false; updatePlayIcon(); });
audioEl.addEventListener('ended', ()=> { isPlaying = false; updatePlayIcon(); });
audioEl.addEventListener('canplay', ()=> { /* ready */ });

sourceSelect.addEventListener('change', () => {
  if(sourceSelect.value === 'audio'){
    // if audio element not started, ensure it plays
    audioEl.play().catch(()=>{});
  } else {
    // switched to YouTube fallback
    // if YT isn't ready it's okay; fake visualizer will run
    if(ytPlayer) { ytPlayer.playVideo(); isPlaying=true; updatePlayIcon(); }
  }
  startVisualizerLoop();
});

/* If user loads a new audio URL or local file, recreate analyser */
audioEl.addEventListener('loadeddata', () => {
  // re-create analyser chain to pick up new media element source
  try{
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    setupAnalyserForAudioElement();
    if(sourceSelect.value === 'audio') startVisualizerLoop();
  }catch(e){ console.warn('setupAnalyserForAudioElement failed', e); }
});

/* If user clicks play/pause, resume audio context if needed */
document.addEventListener('click', () => {
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
});

/* Initialize default visualizer loop (audio selected by default) */
startVisualizerLoop();

/* ======= Cursor trail & hover handling (kept subtle) ======= */
function spawnTrail(x,y){
  if(Math.random() > 0.12) return;
  const el = document.createElement('div');
  el.className = 'trail';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  document.body.appendChild(el);
  setTimeout(()=> el.remove(), 380);
}
window.addEventListener('pointermove', (e) => {
  cursorEl.style.left = e.clientX + 'px';
  cursorEl.style.top = e.clientY + 'px';
  spawnTrail(e.clientX, e.clientY);
});
const interactives = Array.from(document.querySelectorAll('button, a, input, select, #enterText'));
interactives.forEach(el => {
  el.style.cursor = 'none';
  el.addEventListener('pointerenter', ()=> cursorEl.classList.add('hover'));
  el.addEventListener('pointerleave', ()=> cursorEl.classList.remove('hover'));
  el.addEventListener('pointerdown', ()=> { cursorEl.style.transform = 'translate(-50%,-50%) scale(1.25)'; });
  el.addEventListener('pointerup', ()=> { cursorEl.style.transform = 'translate(-50%,-50%) scale(1)'; });
});

/* ======= Fake visual & particle canvases (from your original code) ======= */
const particles = document.getElementById('particles');
const snow = document.getElementById('snow');
const fog = document.getElementById('fog');
const grain = document.getElementById('grain');
const pctx = particles.getContext('2d');
const sctx = snow.getContext('2d');
const fctx = fog.getContext('2d');
const gctx = grain.getContext('2d');

let W = innerWidth, H = innerHeight;
function resizeAll(){ W = innerWidth; H = innerHeight; [particles,snow,fog,grain].forEach(c=>{ c.width = W; c.height = H; }); }
window.addEventListener('resize', resizeAll); resizeAll();

/* small floating particles */
let smalls = [];
for(let i=0;i<90;i++){ smalls.push({ x: Math.random()*W, y: Math.random()*H, r: Math.random()*1.6, vy: 0.2+Math.random()*0.7 }); }
/* snowflakes */
let flakes = [];
for(let i=0;i<60;i++){ flakes.push({ x: Math.random()*W, y: Math.random()*H, r: Math.random()*2+0.8, vy:0.4+Math.random()*0.8, sway:Math.random()*1.6 }); }
/* fog blobs */
let fogBlobs = [];
for(let i=0;i<6;i++){ fogBlobs.push({ x: Math.random()*W, y: Math.random()*H, s: (W/2)*(0.12+Math.random()*0.5), vx:(Math.random()-0.5)*0.06, vy:(Math.random()-0.5)*0.03, alpha:0.02+Math.random()*0.06, phase:Math.random()*Math.PI*2 }); }

function drawParticles(){ pctx.clearRect(0,0,W,H); pctx.fillStyle = 'rgba(255,255,255,0.32)'; for(let p of smalls){ pctx.beginPath(); pctx.arc(p.x,p.y,p.r,0,Math.PI*2); pctx.fill(); p.y -= p.vy * 0.25; if(p.y < -10){ p.y = H + 10; p.x = Math.random()*W; } } }
function drawSnow(){ sctx.clearRect(0,0,W,H); sctx.fillStyle = 'rgba(255,255,255,0.28)'; sctx.beginPath(); for(let f of flakes){ sctx.moveTo(f.x,f.y); sctx.arc(f.x,f.y,f.r,0,Math.PI*2); } sctx.fill(); for(let f of flakes){ f.y += f.vy; f.x += Math.sin((f.y+f.sway)*0.008)*1.6; if(f.y > H + 8){ f.y = -6; f.x = Math.random()*W; } } }
function drawFog(t){
  fctx.clearRect(0,0,W,H);
  for(let b of fogBlobs){
    b.x += b.vx * Math.cos(t*0.0007 + b.phase) * 0.8;
    b.y += b.vy * Math.sin(t*0.0004 + b.phase) * 0.8;
    const g = fctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.s);
    g.addColorStop(0, 'rgba(255,255,255,'+ (b.alpha) +')');
    g.addColorStop(0.35, 'rgba(255,255,255,'+ (b.alpha*0.45) +')');
    g.addColorStop(1, 'rgba(255,255,255,0)');
    fctx.fillStyle = g; fctx.beginPath(); fctx.arc(b.x,b.y,b.s,0,Math.PI*2); fctx.fill();
  }
}
function drawGrain(){ gctx.clearRect(0,0,W,H); gctx.fillStyle = 'rgba(255,255,255,0.02)'; const dots = Math.round(W*H/7000); for(let i=0;i<dots;i++){ const x = Math.random()*W, y = Math.random()*H; gctx.fillRect(x,y,1,1); } }

let last = performance.now();
function frame(t){
  const dt = t - last; last = t;
  drawParticles(); drawSnow(); drawFog(t);
  // occasional flicker sweep
  if(Math.random() < 0.002){ flick.style.opacity = 0.28; setTimeout(()=> flick.style.opacity = 0, 140); }
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* utility spawn helpers (no-ops kept for parity) */
function spawnSnow(){ /* already running */ }
function spawnFog(){ /* already running */ }
function spawnGrain(){ drawGrain(); }

/* Expose debug helpers */
window.__VOID = { spawnSnow, spawnFog, spawnGrain, startVisualizerLoop };

/* Safety: resume audioCtx on user gesture if needed */
document.addEventListener('click', ()=>{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); });
</script>
</body>
</html>
